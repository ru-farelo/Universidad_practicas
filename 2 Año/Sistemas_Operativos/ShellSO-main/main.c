//Autores --> Roi Cabana Roca, Ruben Fernandez Farelo//Logins  --> roi.cabana@duc.es, ruben.fernandez.farelo@udc.es#include <stdio.h>#include <stdlib.h>#include "commands.h"#include "list.h"#include <string.h>#include <time.h>#include <unistd.h>#include <sys/utsname.h>#include <sys/stat.h>#include <errno.h>#include <sys/shm.h>#include <pwd.h>#include <grp.h>#include <dirent.h>#include <sys/wait.h>#include <fcntl.h>#include <stdbool.h>#include <sys/mman.h>#include <sys/resource.h>#define ANSI_COLOR_GREEN   "\x1b[32m"#define ANSI_COLOR_CYAN    "\x1b[36m"#define ANSI_COLOR_RESET   "\x1b[0m"#define UNUSED __attribute__((unused))#define v 128#define MAX_INPUT_SIZE 1024#define MAX_TOKENS 64#define MAX_BUF 200#define MAX_PATH 1024#define MAX 256#define MAX_SIZE 1024#define MAXVAR 1024typedef struct ShellData{    linkedList history;    linkedList memlist;    linkedList proceslist;    int recursiveCommandLevel;    int runningShell;    char *** env;}* ShellData;struct SEN{    char * nombre;    int senal;} ;int split_string    (char * cadena, char * trozos[]);void authors        (char * tokens[], int lenght, ShellData data);void printDate      (char * tokens[], int lenght, ShellData data);void printHelp      (char * tokens[], int lenght, ShellData data);void printHist      (char * tokens[], int lenght, ShellData data);void executeCommand (char * tokens[], int lenght, ShellData data);void infosys        (char * tokens[], int lenght, ShellData data);void pid            (char * tokens[], int lenght, ShellData data);void carpeta        (char * tokens[], int lenght, ShellData data);void create         (char * tokens[], int lenght, ShellData data);void statlist       (char * tokens[], int lenght, ShellData data);void listdir        (char * tokens[], int lenght, ShellData data);void deltree        (char * tokens[], int lenght, ShellData data);void deletos        (char * tokens[], int lenght, ShellData data);void exitShell      (char * tokens[], int lenght, ShellData data);void allocate       (char * tokens[], int lenght, ShellData data);void deallocate     (char * tokens[], int lenght, ShellData data);void io             (char * tokens[], int lenght, ShellData data);void memdump        (char * tokens[], int lenght, ShellData data);void memfill        (char * tokens[], int lenght, ShellData data);void memory         (char * tokens[], int lenght, ShellData data);void recurse        (char * tokens[], int lenght, ShellData data);void Recursiva (int n);//void LlenarMemoria (void *p, size_t cont, unsigned char byte);void * ObtenerMemoriaShmget (key_t clave, size_t tam);//void * MapearFichero (char * fichero, int protection);ssize_t LeerFichero (char *f, void *p, size_t cont);void do_I_O_read (char *ar[]);ssize_t EscribirFichero (char *ar[],int overwrite);void Do_pmap (void);//PRACTICA 3void priority(char *tokens[],int lenght, ShellData data);void showvar(char *tokens[],int lenght, ShellData data);void changevar(char *tokens[],int lenght, ShellData data);void Cmd_fork(char *tokens[],int lenght, ShellData data);void execute(char * tokens[], int lenght, ShellData data);void showenv(char *tokens[],int lenght, ShellData data);char LetraTF (mode_t m);char * ConvierteModo (mode_t m, char *permisos);void printFileDetails(char * file, bool plong, bool pacc, bool plink, bool colorOutput);int isDir(char *path);void printListDir(char * path, bool plong, bool pacc, bool plink, bool phid, bool preca, bool precb);void delete_item(char *file);int process_input(char * input, ShellData data);void Cmd_foreground(char *tokens[], int lenght, ShellData data);void Cmd_background(char *tokens[], int lenght, ShellData data);void Cmd_job(char *tokens[], int lenght, ShellData data);void Cmd_listJobs(char *tokens[], int lenght, ShellData data);void Cmd_delJobs(char *tokens[], int lenght, ShellData data);ShellData createShellData(char ***env);struct cmd{    char* cmd_name;    void (*cmd_fun)(char* tokens[], int lenght, ShellData data);    char* cmd_desc;} cmds[] = {        {AUTHORS_NAME,    authors,        AUTHORS_DESCRIPTION},        {PID_NAME,        pid,            PID_DESCRIPTION},        {FOLDER_NAME,     carpeta,        FOLDER_DESCRIPTION},        {TIME_NAME,       printDate,      TIME_DESCRIPTION},        {HISTORY_NAME,    printHist,      HISTORY_DESCRIPTION},        {COMMAND_NAME,    executeCommand, COMMAND_DESCRIPTION},        {CREATE_NAME,     create,         CREATE_DESCRIPTION},        {STAT_NAME,       statlist,       STAT_DESCRIPTION},        {LIST_NAME,       listdir,        LIST_DESCRIPTION},        {DELETE_NAME,     deletos,        DELETE_DESCRIPTION},        {DELTREE_NAME,    deltree,        DELTREE_DESCRIPTION},        {INFOSYS_NAME,    infosys,        INFOSYS_DESCRIPTION},        {HELP_NAME,       printHelp,      HELP_DESCRIPTION},        {END_NAME,        exitShell,      END_DESCRIPTION},        {EXIT_NAME,       exitShell,      EXIT_DESCRIPTION},        {BYE_NAME,        exitShell,      BYE_DESCRIPTION},        {ALLOCATE_NAME,   allocate,       ALLOCATE_DESCRIPTION},        {DEALLOCATE_NAME, deallocate,     DEALLOCATE_DESCRIPTION},        {MEMDUMP_NAME,    memdump,        MEMDUMP_DESCRIPTION},        {MEMFILL_NAME,    memfill,        MEMFILL_DESCRIPTION},        {IO_NAME,         io,             IO_DESCRIPTION},        {MEMORY_NAME,     memory,         MEMDUMP_DESCRIPTION},        {RECURSE_NAME,    recurse,        RECURSE_DESCRIPTION},        {PRIORITY_NAME,   priority,       PRIORITY_DESCRIPTION},        {SHOWVAR_NAME,    showvar,        SHOWVAR_DESCRIPTION},        {CHANGEVAR_NAME,  changevar,      CHANGEVAR_DESCRIPTION},        {FORK_NAME,       Cmd_fork,       FORK_DESCRIPTION},        {EXECUTE_NAME,    execute,        EXECUTE_DESCRIPTION},        {SHOWENV_NAME,    showenv,        SHOWENV_DESCRIPTION},        {LISTJOBS_NAME,Cmd_listJobs,LISTJOBS_DESCRIPTION},        {JOB_NAME,Cmd_job,JOB_DESCRIPTION},        {DELJOBS_NAME,Cmd_delJobs,DELJOBS_DESCRIPTION},        {NULL   , NULL, NULL}};ShellData createShellData(char *** env) {    ShellData data = malloc(sizeof(struct ShellData));    data->history = createList();    data->memlist=createList();    data->proceslist=createList();    data->recursiveCommandLevel=0;    data->runningShell=1;    data-> env =env;    return data;}int main(int argc, char*argv[],char * env[]){    char input[MAX_INPUT_SIZE];    ShellData data = createShellData(&env);    while (data->runningShell)    {        data->recursiveCommandLevel=0;        printf("> ");        fgets(input,MAX_INPUT_SIZE,stdin);        if(process_input(input, data))            insert(data->history, input, sizeof (input));    }}void authors(char * tokens[], int lenght, UNUSED ShellData data){    bool pl=false;    bool pn=false;    for(int i = 0;i<lenght;i++){        if(tokens[i][0]!='-')            break;        if(strcmp(tokens[i],"-l")==0){            pl=true;        }else if(strcmp(tokens[i],"-n")==0){            pn=true;        }    }    if(pl||lenght==0)    {        printf("Logins: roi.cabana@duc.es, ruben.fernandez.farelo@udc.es\n");    }    if(pn||lenght==0)    {        printf("Nombres: Roi Cabana Roca, Ruben Fernandez Farelo\n");    }}void printDate(char * tokens[], int lenght, UNUSED ShellData data){    bool pd=false;    bool ph=false;    for(int i = 0;i<lenght;i++){        if(tokens[i][0]!='-')            break;        if(strcmp(tokens[i],"-d")==0){            pd=true;        }else if(strcmp(tokens[i],"-h")==0){            ph=true;        }    }    time_t t = time(NULL);    struct tm tm = *localtime(&t);    if(pd||lenght==0)    {        printf("Dia: %d/%d/%d\n",tm.tm_mday,tm.tm_mon+1,tm.tm_year+1900);    }    if(ph||lenght==0)    {        printf("Hora: %d:%d:%d\n",tm.tm_hour,tm.tm_min,tm.tm_sec);    }}void printHelp(char * tokens[], int lenght, UNUSED ShellData data){    if(lenght==0){        printf("Comandos disponibles:\n");        for (int i = 0; cmds[i].cmd_name != NULL; i++)        {            printf("%s ",cmds[i].cmd_name);        }        printf("\n");    }else{        for (int i = 0; cmds[i].cmd_name != NULL; i++)        {            if (strcmp(tokens[0],cmds[i].cmd_name)==0)            {                printf("Uso del comando %s:\n%s\n",cmds[i].cmd_name,cmds[i].cmd_desc);            }        }    }}void printHist(UNUSED char * tokens[], UNUSED int lenght, ShellData data) {    int stop = 100000;    if(lenght>0 && tokens[0][0]=='-') {        if (strcmp(tokens[0], "-c") == 0) {            clearList(data->history);            return;        }else{            stop= atoi(tokens[0]+1);        }    }    if (!isEmpty(data->history)) {        pos p = first(data->history);        for (int count = 0; !atEnd(data->history, p) && count < stop; count++) {            printf("%d) %s\n", count, (char *) getValue(data->history, p));            p = next(data->history, p);        }    }else    {        printf("* Historial Vacio *\n");    }}void executeCommand(char * tokens[], UNUSED int lenght, ShellData data){    if(data->recursiveCommandLevel<3)    {        char*end;        int pos = strtol(tokens[0], &end, 10);        if (tokens[0] == end)            return;        if (getSize(data->history) - 1 < pos)            return;        char*commandString = (char *) getValue(data->history, getByNumericPos(data->history, pos));        void *command = malloc(sizeof(char)*MAX_TOKENS);        memcpy(command,commandString,sizeof(char)*MAX_TOKENS);        data->recursiveCommandLevel=data->recursiveCommandLevel+1;        process_input(command,data);        free(command);    }else{        printf("Error, demasiada recursividad.\n");    }}void infosys(char* tokens[], int lenght, ShellData data){    struct utsname info;    uname(&info);    printf("Nombre Sistema -> %s\n", info.sysname);    printf("Nombre Nodo    -> %s\n", info.nodename);    printf("Release        -> %s\n", info.release);    printf("Version        -> %s\n", info.version);    printf("Maquina        -> %s\n", info.machine);}void pid(char * tokens[], int lenght, ShellData data){    bool pp=false;    for(int i = 0;i<lenght;i++){        if(tokens[i][0]!='-')            break;        if(strcmp(tokens[i],"-p")==0){            pp=true;        }    }    if(lenght==0)    {        printf("Shell Pid: %d\n",getpid());    }else if(pp)    {        printf("Parent Pid: %d\n",getppid());    }}void carpeta(char * tokens[], int lenght,UNUSED ShellData data){    char ruta[MAX_BUF];    if(lenght==0) {        getcwd(ruta, MAX_BUF);        printf("Directorio actual de trabajo: %s\n", ruta);    }    else if (lenght==1)    {        if(chdir(tokens[0])==-1){            printf("No se ha podido cambiar a %s: %s\n", tokens[0], strerror(errno));        }else{            getcwd(ruta, MAX_BUF);            printf("Directorio actual de trabajo: %s\n", ruta);        }    }}void create(char * tokens[], int lenght, ShellData data){    bool pf=false;    for(int i = 0;i<lenght;i++){        if(tokens[i][0]!='-')            break;        if(strcmp(tokens[i],"-f")==0){            pf=true;        }    }    int fd;    if(pf){        fd = open(tokens[1],O_CREAT,O_RDWR,S_IRWXU); //* Se abria solo para escritura y no habia permisos        if(fd == -1)        {            printf("No se puede crear el fichero %s: %s\n", tokens[1], strerror(errno));        }else        if (close(fd) == -1) {            printf("Ha habido un error al cerrar: %s", strerror(errno));        }    }    else if (lenght==1) {        int directorio = mkdir(tokens[0], 0700);        if (directorio == -1) {            printf("No se puede crear el fichero %s: %s\n", tokens[0], strerror(errno));        }    }}void statlist (char * tokens[], int lenght, UNUSED ShellData data){    int fileIndex ;    bool plong=false;    bool pacc=false;    bool plink=false;    for(fileIndex = 0;fileIndex<lenght;fileIndex++){        if(tokens[fileIndex][0]!='-')            break;        if(strcmp(tokens[fileIndex],"-long")==0){            plong=true;        }else if(strcmp(tokens[fileIndex],"-acc")==0){            pacc=true;        } else if(strcmp(tokens[fileIndex],"-link")==0){            plink=true;        }    }    if (lenght==0||fileIndex==lenght){        char ruta[MAX_BUF];        getcwd(ruta, MAX_BUF);        printFileDetails(ruta,plong,pacc,plink,false);        return;    }    for(;fileIndex<lenght;fileIndex++){//mirar        printFileDetails(tokens[fileIndex],plong,pacc,plink,false);    }}void listdir(char *tokens[],int lenght,UNUSED ShellData data) {    bool plong=false,            pacc=false,            plink=false,            phid=false,            preca=false,            precb=false;    int fileIndex;    for(fileIndex = 0;fileIndex<lenght;fileIndex++){        if(tokens[fileIndex][0]!='-')            break;        if(strcmp(tokens[fileIndex],"-long")==0){            plong=true;        }else if(strcmp(tokens[fileIndex],"-acc")==0){            pacc=true;        } else if(strcmp(tokens[fileIndex],"-link")==0){            plink=true;        }else if(strcmp(tokens[fileIndex],"-hid")==0){            phid=true;        }else if(strcmp(tokens[fileIndex],"-reca")==0){            preca=true;        }else if(strcmp(tokens[fileIndex],"-recb")==0){            precb=true;        }    }    if (lenght==0||fileIndex==lenght){        printListDir(".", plong, pacc, plink, phid, preca, precb);        return;    }    for(;fileIndex<lenght;fileIndex++){        printListDir(tokens[fileIndex], plong, pacc, plink, phid, preca, precb);    }}void deltree(char * tokens[], int lenght,UNUSED ShellData data){    for(int i=0; i < lenght; i++)        delete_item(tokens[i]);}void deletos(char *tokens[], int lenght,UNUSED ShellData data) {    for(int i = 0;i<lenght;i++){        if(remove(tokens[i])==-1){            printf("Could not delete %s: %s\n", tokens[i], strerror(errno));        }else{            printf("Borrar %s\n", tokens[i]);        }    }}void exitShell(UNUSED char *tokens[],UNUSED int lenght,UNUSED ShellData data){    exit(0);}void printListDir(char * path, bool plong, bool pacc, bool plink, bool phid, bool preca, bool precb){    printf(ANSI_COLOR_CYAN"\n************ %s"ANSI_COLOR_RESET"\n",path);    char subDir[MAX_BUF];    struct dirent * entrada = NULL;    DIR * dir = opendir(path);    if (dir == NULL) {        printf("Error al abrir el directorio %s: %s\n", path, strerror(errno));        return;    }    if(precb){        while ((entrada = readdir(dir)) != NULL) {            if (entrada->d_name[0]!='.'||phid) {                strcpy(subDir, path);                strcat(subDir,"/");                strcat(subDir,entrada->d_name);                if(isDir(subDir))                    printListDir(subDir, plong, pacc, plink, phid, preca, precb);            }        }        closedir(dir);        dir=NULL;        entrada=NULL;    }    dir = opendir(path);    if (dir == NULL) {        printf("Error al abrir el directorio %s: %s\n", path, strerror(errno));    }    while ((entrada = readdir(dir)) != NULL) {        if (entrada->d_name[0]!='.'||phid) {            strcpy(subDir, path);            strcat(subDir,"/");            strcat(subDir,entrada->d_name);            printFileDetails(subDir,plong,pacc,plink,true);        }    }    closedir(dir);    dir=NULL;    entrada=NULL;    if(preca&&!precb){        dir = opendir(path);        if (dir == NULL) {            printf("Error al abrir el directorio %s: %s\n", path, strerror(errno));        }        while ((entrada = readdir(dir)) != NULL) {            if (entrada->d_name[0]!='.'||phid) {                strcpy(subDir, path);                strcat(subDir,"/");                strcat(subDir,entrada->d_name);                if(isDir(subDir))                    printListDir(subDir, plong, pacc, plink, phid, preca, precb);            }        }        closedir(dir);        dir=NULL;        entrada=NULL;    }}int process_input(char * input, ShellData data){    char* tokens[MAX_TOKENS];    int lenght = split_string(input, tokens);    if(lenght==0)return 0;    int i;    for (i = 0; cmds[i].cmd_name != NULL; i++)    {        if (strcmp(tokens[0],cmds[i].cmd_name)==0)        {            cmds[i].cmd_fun(tokens +1,lenght-1, data);            return 1;        }    }    if(lenght==1 || tokens[lenght-1][0]!='&'){        Cmd_foreground(tokens,lenght,data);    }else{        tokens[lenght - 1] = (char *) NULL;        Cmd_background(tokens,lenght-1,data);    }    return 0;}int isDir(char *path) {    struct stat st;    if (stat(path, &st) != 0)        return 0;    return S_ISDIR(st.st_mode);}void printFileDetails(char * file, bool plong, bool pacc, bool plink, bool colorOutput){    struct stat sb;    char permisos[v];    char str[MAX];    time_t tempo;//    struct tm *fmodif;//    struct tm *facceso;    if(stat(file,&sb) < 0)    {        perror("Error: ");        return;    }    if(plong){        //fecha ultimo acceso        tempo = pacc?sb.st_atime:sb.st_mtime;        strftime(str,MAX,"%Y/%m/%d-%H:%M",localtime(&tempo));        printf("%s ", str);        //Numero de enlaces        printf("%3ld ", sb.st_nlink);        //Numero de inodo        printf("(%8ld) ", sb.st_ino);        //Nombre usuario Propietario        printf("%8s ", getpwuid(sb.st_uid)->pw_name);        //Nombre Grupo        printf("%8s ", getgrgid(sb.st_gid)->gr_name);        //Permisos        ConvierteModo(sb.st_mode,permisos);        printf("%s ", permisos);        //Tamaño        printf("%8ld ", sb.st_size);        //Nombre        printf(colorOutput&&S_ISDIR(sb.st_mode)?ANSI_COLOR_GREEN"%s"ANSI_COLOR_RESET:"%s", file);        if(plink){// hay que comprobar en letra tf que sea enlace simbolico            char lPath[MAX_SIZE];            readlink(file, lPath, MAX_SIZE);            printf(" -> %s", lPath);        }        printf("\n");    }else{        printf(colorOutput&&S_ISDIR(sb.st_mode)?"%10ld "ANSI_COLOR_GREEN"%s\n"ANSI_COLOR_RESET:"%10ld %s\n", sb.st_size, file);    }}//Funcion proporcionada por el equipo docente de la UDCchar LetraTF (mode_t m){    switch (m&S_IFMT) { /*and bit a bit con los bits de formato,0170000 */        case S_IFSOCK: return 's'; /*socket */        case S_IFLNK: return 'l'; /*symbolic link*/        case S_IFREG: return '-'; /* fichero normal*/        case S_IFBLK: return 'b'; /*block device*/        case S_IFDIR: return 'd'; /*directorio */        case S_IFCHR: return 'c'; /*char device*/        case S_IFIFO: return 'p'; /*pipe*/        default: return '?'; /*desconocido, no deberia aparecer*/    }}void delete_item(char *file) {    struct stat st;    if(lstat(file, &st) == -1) {        printf("Could not access %s: %s\n", file, strerror(errno));    }    if((st.st_mode & S_IFMT) == S_IFDIR) { // path es un directorio        DIR *d;        struct dirent *ent;        if((d = opendir(file)) == NULL) {            printf("Could not open %s: %s\n", file, strerror(errno));        }        while((ent = readdir(d)) != NULL) {            char new_path[MAX_PATH];            if(strcmp(ent->d_name, ".") == 0 || strcmp(ent->d_name, "..") == 0)                continue;            sprintf(new_path, "%s/%s", file, ent->d_name);            delete_item(new_path);        }        closedir(d);    }    if(remove(file) == -1) {        printf("Could not delete %s: %s\n", file, strerror(errno));    }    printf("Borrar %s\n", file);}int split_string(char * cadena, char * trozos[]){    int i=1;    if ((trozos[0]=strtok(cadena," \n\t"))==NULL)        return 0;    while ((trozos[i]=strtok(NULL," \n\t"))!=NULL)        i++;    return i;}//Funcion proporcionada por el equipo docente de la UDC.char * ConvierteModo (mode_t m, char *permisos){    strcpy (permisos,"---------- ");    permisos[0]=LetraTF(m);    if (m&S_IRUSR) permisos[1]='r';    /*propietario*/    if (m&S_IWUSR) permisos[2]='w';    if (m&S_IXUSR) permisos[3]='x';    if (m&S_IRGRP) permisos[4]='r';    /*grupo*/    if (m&S_IWGRP) permisos[5]='w';    if (m&S_IXGRP) permisos[6]='x';    if (m&S_IROTH) permisos[7]='r';    /*resto*/    if (m&S_IWOTH) permisos[8]='w';    if (m&S_IXOTH) permisos[9]='x';    if (m&S_ISUID) permisos[3]='s';    /*setuid, setgid y stickybit*/    if (m&S_ISGID) permisos[6]='s';    if (m&S_ISVTX) permisos[9]='t';    return permisos;}//P2 ********************************************************//parte de memoria a usartypedef enum{    ALLOC_MALLOC,    ALLOC_MMAP,    ALLOC_SHARED}allocType;typedef struct{    allocType tipo_mem;                    //tipo de asignacion    int tam;                              //tamaño reservado en memoria    time_t time;    void * direccion;                     //dirección de memoria    char nombre_archivo[64];              //para el mmap    int key;                              //clave cl para shared} memData;enum allocateOption{    PRINTHELP,    DEF,    MALLOC,    SHARED,    CREATESHARED,    MMAP,    ADDR,    DELKEY};enum ioOption{    PRINTHELPIO,    READ,    WRITE};////           P2// Comando allocate para abajovoid printListMem(linkedList memList,allocType type){    printf("******Lista de bloques asignados para el proceso\n");    if(!isEmpty(memList)){        char momento[32];        for(pos p = first(memList);!atEnd(memList,p);p= next(memList,p)){            memData *data = getValue(memList,p);            if(type!=-1 && type!=data->tipo_mem)                continue;            strftime(momento, sizeof(momento), "%a %b %d  %H:%M:%S %Y", localtime(&data->time));            switch (data->tipo_mem) {                case ALLOC_MALLOC:                    printf("%p: size: %d malloc %s\n", data->direccion, data->tam, momento);                    break;                case ALLOC_MMAP:                    printf("%p : size:%d mmap %s (fd: %d) %s\n",                           data->direccion, data->tam, data->nombre_archivo, data->key, momento);                    break;                case ALLOC_SHARED:                    printf("%p : size:%d shared memory (key: %d) %s\n", data->direccion, data->tam, data->key, momento);                    break;            }        }    }else{        printf("lista vacia\n");    }}void do_AllocateMmap(char *arg[], linkedList memlist){    char *perm;    void *p;    int protection=0;    memData memdata;    if (arg[0]==NULL)    {        printListMem(memlist,ALLOC_MMAP);        return;    }    if ((perm=arg[1])!=NULL && strlen(perm)<4) {        if (strchr(perm,'r')!=NULL) protection|=PROT_READ;        if (strchr(perm,'w')!=NULL) protection|=PROT_WRITE;        if (strchr(perm,'x')!=NULL) protection|=PROT_EXEC;    }    int df, map=MAP_PRIVATE,modo=O_RDONLY;    struct stat s;    if (protection&PROT_WRITE)        modo=O_RDWR;    if (stat(arg[0],&s)==-1 || (df=open(arg[0], modo))==-1        || (p=mmap (NULL,s.st_size, protection,map,df,0))==MAP_FAILED)    {        perror ("Imposible mapear fichero");        return;    }    strcpy(memdata.nombre_archivo,arg[0]);    memdata.direccion=p;    memdata.time = time(NULL);    memdata.tipo_mem=ALLOC_MMAP;    memdata.tam=s.st_size;    insert(memlist,&memdata, sizeof(memdata));    printf("fichero %s mapeado en %p\n", arg[0], p);}void do_allocate_malloc(char *tokens[], linkedList memlist){    memData memdata;    void *dir;    if(tokens[0] == NULL){        printListMem(memlist,ALLOC_MALLOC);        return;    }    memdata.tam = atoi(tokens[0]);    dir = malloc(memdata.tam);    if(dir == NULL){        perror("Cannot allocate:");    }    memdata.direccion = dir;    memdata.time = time(NULL);    memdata.tipo_mem=ALLOC_MALLOC;    if(!insert(memlist, &memdata, sizeof(memData))){        printf("mal\n");    }    printf("Allocated %d at %p\n", memdata.tam, memdata.direccion);}//Proporcionado por el equipo docentevoid do_AllocateCreateshared (char *tr[],linkedList memlist){    key_t cl;    size_t tam;    void *p;    if (tr[0]==NULL || tr[1]==NULL) {        printListMem(memlist,ALLOC_SHARED);        return;    }    cl=(key_t)  strtoul(tr[0],NULL,10);    tam=(size_t) strtoul(tr[1],NULL,10);    if (tam==0) {        printf ("No se asignan bloques de 0 bytes\n");        return;    }    if ((p=ObtenerMemoriaShmget(cl,tam))!=NULL)        printf ("Asignados %lu bytes en %p\n",(unsigned long) tam, p);    else        printf ("Imposible asignar memoria compartida clave %lu:%s\n",(unsigned long) cl,strerror(errno));}void * ObtenerMemoriaShmget (key_t clave, size_t tam){    void * p;    int aux,id,flags=0777;    struct shmid_ds s;    if (tam)     /*tam distito de 0 indica crear */        flags=flags | IPC_CREAT | IPC_EXCL;    if (clave==IPC_PRIVATE)  /*no nos vale*/    {errno=EINVAL; return NULL;}    if ((id=shmget(clave, tam, flags))==-1)        return (NULL);    if ((p=shmat(id,NULL,0))==(void*) -1){        aux=errno;        if (tam)            shmctl(id,IPC_RMID,NULL);        errno=aux;        return (NULL);    }    shmctl (id,IPC_STAT,&s);    /* Guardar en la lista   InsertarNodoShared (&L, p, s.shm_segsz, clave); */    return (p);}void allocate_shared(char *arg[], linkedList memlist){    key_t k;    void *p;    if(arg[0]==NULL) {        printListMem(memlist,ALLOC_SHARED);        return;    }    k = (key_t) atoi(arg[0]);    if ((p = ObtenerMemoriaShmget(k, 0)) == NULL) {        perror("Cannot allocate:");    } else {        //Registramos el bloque en la lista        memData memdata;        memdata.direccion = p;        memdata.tam = 0;        memdata.time = time(NULL);        memdata.tipo_mem=ALLOC_SHARED;        memdata.key = k;        insert(memlist, &memdata,sizeof(memData));        printf("Allocated shared memory (key %d) at %p\n", k, p);    }}//ALLOCATEvoid allocate(char * tokens[], int lenght,ShellData data ) {    enum allocateOption option = lenght == 0 ? DEF : PRINTHELP;    for (int i = 0; i < lenght; i++) {        if (tokens[i][0] != '-')            break;        if (strcmp(tokens[i], "-malloc") == 0) {            option = MALLOC;            break;        } else if (strcmp(tokens[i], "-shared") == 0) {            option = SHARED;            break;        } else if (strcmp(tokens[i], "-createshared") == 0) {            option = CREATESHARED;            break;        } else if (strcmp(tokens[i], "-mmap") == 0) {            option = MMAP;            break;        }    }    switch (option) {        case PRINTHELP:            printf("Uso del comando %s:\n%s\n", ALLOCATE_NAME, ALLOCATE_DESCRIPTION);            break;        case DEF:            printListMem(data->memlist, -1); //el segundo parametro nose cual poner            break;        case MALLOC:            do_allocate_malloc(tokens+1, data->memlist);            break;        case SHARED:            if (lenght == 2) {                char *params[] = {tokens[1], tokens[2]};                allocate_shared(params, data->memlist);                break;            }else{                printListMem(data->memlist,ALLOC_SHARED);            }        case CREATESHARED:            if (lenght == 3) {                char *params[] = {tokens[1], tokens[2]};                do_AllocateCreateshared(params, data->memlist);            }else{                printListMem(data->memlist,ALLOC_SHARED);            }            break;        case MMAP:            if (lenght >= 2) {                char *params[] = {tokens[1], tokens[2]};                do_AllocateMmap(params, data->memlist);                break;            }else{                printListMem(data->memlist,ALLOC_MMAP);            }        case ADDR:            break;        case DELKEY:            break;    }}//COMANDO deallocate para abajovoid dealloc_malloc(char *size, linkedList  memlist) {    if (size == NULL) {        printListMem(memlist, ALLOC_MALLOC);        return;    }    int n = atoi(size);    if (!isEmpty(memlist))    {        for (pos p = first(memlist); !atEnd(memlist, p); p = next(memlist, p)) {            memData *data = ((memData *) getValue(memlist, p));            if (data->tipo_mem == ALLOC_MALLOC && data->tam == n) { ;                free(data->direccion);                printf("deallocated %d at %p\n", data->tam, data->direccion);                listremove(memlist, p);                free(data);                return;            }        }    }    printf("No hay bloque de ese tamano asignado con malloc");}void dealloc_mmap(char *tokens, linkedList memlist)   {    if(tokens == NULL){        printListMem(memlist,ALLOC_MALLOC);        return;    }    printf("Intendando %s",tokens);    if (!isEmpty(memlist))    {        for (pos p = first(memlist); !atEnd(memlist, p); p = next(memlist, p)) {            memData *data = ((memData *) getValue(memlist, p));            printf("INDEXED %s \n",data->nombre_archivo);            if (data->tipo_mem == ALLOC_MMAP && strcmp(data->nombre_archivo, tokens) == 0) {                if(munmap(data->direccion, data->tam) == -1){                    //devuelve un error                    perror("Cannot dealloc:");                }                close(data->key);                printf("block at address %p deallocated (mmap)\n", data->direccion);                listremove(memlist, p);                free(data);                return;            }        }    }    printf("Fichero %s no mapeado\n",tokens);}void dealloc_shared(char *key, linkedList memlist){    if(key == NULL){        printListMem(memlist,ALLOC_SHARED);        return;    }    int n = atoi(key);    if (!isEmpty(memlist))    {        for (pos p = first(memlist); !atEnd(memlist, p); p = next(memlist, p)) {            memData *data = ((memData *) getValue(memlist, p));            if (data->tipo_mem == ALLOC_SHARED && data->key == n) { ;                if(shmdt(data->direccion) == -1){                    perror("Error");                    return;                }                printf("block at address %p deallocated (shared)\n", data->direccion);                listremove(memlist, p);                free(data);                return;            }        }    }    printf("No hay bloque de esa clave mapeado en el proceso");}void do_DeallocateDelkey (char *args[]){    key_t clave;    int id;    char *key=args[0];    if (key==NULL || (clave=(key_t) strtoul(key,NULL,10))==IPC_PRIVATE){        printf ("      delkey necesita clave_valida\n");        return;    }    if ((id=shmget(clave,0,0666))==-1){        perror ("shmget: imposible obtener memoria compartida");        return;    }    if (shmctl(id,IPC_RMID,NULL)==-1)        perror ("shmctl: imposible eliminar memoria compartida\n");}void dealloc_addres(char *adr,linkedList memlist){    char str[64];    void * n = (void *) strtol(adr, NULL, 16);    if (!isEmpty(memlist))    {        for (pos p = first(memlist); !atEnd(memlist, p); p = next(memlist, p)) {            memData *data = ((memData *) getValue(memlist, p));            if (data->direccion == n) {                switch (data->tipo_mem) {                    case ALLOC_MALLOC:                        //TODO Revisar                        sprintf(str, "%d", data->tam);                        dealloc_malloc(str,memlist);                        return;                    case ALLOC_SHARED:                        //TODO Revisar                        sprintf(str, "%d", data->key);                        dealloc_shared(str,memlist);                        return;                    case ALLOC_MMAP:                        dealloc_mmap(data->nombre_archivo,memlist);                        return;                }            }        }    }}void LlenarMemoria (void *p, size_t cont, unsigned char byte){    unsigned char *arr=(unsigned char *) p;    size_t i;    for (i=0; i<cont;i++)        arr[i]=byte;}#define TAMANO 2048void Recursiva (int n){    char automatico[TAMANO];    static char estatico[TAMANO];    printf ("parametro:%3d(%p) array %p, arr estatico %p\n",n,&n,automatico, estatico);    if (n>0)        Recursiva(n-1);}void deallocate(char * tokens[], int lenght,ShellData data ) {    enum allocateOption option = lenght == 0 ? DEF : ADDR;    for (int i = 0; i < lenght; i++) {        if (tokens[i][0] != '-')            break;        if (strcmp(tokens[i], "-malloc") == 0) {            option = MALLOC;            break;        } else if (strcmp(tokens[i], "-shared") == 0) {            option = SHARED;            break;        } else if (strcmp(tokens[i], "-addr") == 0) {            option = ADDR;            break;        } else if (strcmp(tokens[i], "-mmap") == 0) {            option = MMAP;            break;        } else if (strcmp(tokens[i], "-delkey") == 0) {            option = DELKEY;            break;        }    }    switch (option) {        case PRINTHELP:            printf("Uso del comando %s:\n%s\n", DEALLOCATE_NAME, DEALLOCATE_DESCRIPTION);            break;        case DEF:            printListMem(data->memlist, -1); //el segundo parametro nose cual poner            break;        case MALLOC:            dealloc_malloc(tokens[1], data->memlist);            break;        case ADDR:            dealloc_addres(tokens[0], data->memlist);            break;        case MMAP:            dealloc_mmap(tokens[1], data->memlist);            break;        case SHARED:            dealloc_shared(tokens[1], data->memlist);            break;        case DELKEY:            do_DeallocateDelkey(tokens+1);            break;        case CREATESHARED:            break;    }}void memdump(char *trozos[],int lenght, ShellData data ){    char *dir;    int bytes = 25;    int n = 0, i;    if(lenght<2){        printf("Faltan parametros.");        return;    }    dir = (char *) strtol(trozos[0], NULL, 16);    bytes = atoi(trozos[1]);    while(n < bytes){        for(i = 0 + n; i < 25+n && i < bytes; i++){            if(dir[i] > 31 && dir[i] < 127){                printf(" %2c", dir[i]);            }else{                printf("   ");            }        }        printf("\n");        for(i = 0 + n; i < 25+n && i < bytes; i++){            printf(" %02hhX", dir[i]);        }        printf("\n");        n+= 25;    }}//iovoid io (char * tokens[], int lenght, ShellData data) {    enum ioOption option = PRINTHELPIO;    int overwrite = 0;    if (lenght > 0) {        if (strcmp(tokens[0], "read") == 0) {            option = READ;        } else if (strcmp(tokens[0], "write") == 0) {            option = WRITE;            if (strcmp(tokens[1], "-o") == 0) {                overwrite = 1;            }        }    }    switch (option) {        case PRINTHELPIO:            printf("Uso del comando %s:\n%s\n", IO_NAME, IO_DESCRIPTION);            break;        case READ:            do_I_O_read(tokens+1);            break;        case WRITE:            EscribirFichero(tokens+overwrite+1,overwrite );// Es el de ayuda pero creo que necesita algo mas            break;    }}ssize_t EscribirFichero (char *ar[],int overwrite) {    ssize_t n;    int df, aux, flags = O_CREAT | O_EXCL | O_WRONLY;//abria que controlar si esta la -o que es el overwrite    if (overwrite)        flags = O_CREAT | O_WRONLY | O_TRUNC;    int cont = 128;    if (ar[0] == NULL || ar[1] == NULL || ar[2] == NULL) {        printf("faltan parametros\n");        return -1;    }    cont = atoll(ar[2]);    if ((df = open(ar[0], flags, 0777)) == -1) {        perror("Imposible leer fichero");        return -1;    }    void *p = (void*)strtoul(ar[1],NULL,16);    if ((n=write(df, p,cont))==-1){        aux=errno;        close(df);        errno=aux;        perror ("Imposible escribir fichero");        return -1;    }    close (df);    printf ("escritos %lld bytes de %s en %p\n",(long long) n,ar[0],p);    return n;}void do_I_O_read (char *ar[]){    void *p;    size_t cont=-1;    ssize_t n;    if (ar[0]==NULL || ar[1]==NULL){        printf ("faltan parametros\n");        return;    }    p= (void*)strtoul(ar[1],NULL,16);//cadtop(ar[1]);  /*convertimos de cadena a puntero*/    if (ar[2]!=NULL)        cont=(size_t) atoll(ar[2]);    if ((n=LeerFichero(ar[0],p,cont))==-1)        perror ("Imposible leer fichero");    else        printf ("leidos %lld bytes de %s en %p\n",(long long) n,ar[0],p);}ssize_t LeerFichero (char *f, void *p, size_t cont){    struct stat s;    ssize_t  n;    int df,aux;    if (stat (f,&s)==-1 || (df=open(f,O_RDONLY))==-1)        return -1;    if (cont==-1)   /* si pasamos -1 como bytes a leer lo leemos entero*/        cont=s.st_size;    if ((n=read(df,p,cont))==-1){        aux=errno;        close(df);        errno=aux;        return -1;    }    close (df);    return n;}void memfill(char *trozos[], int lenght, ShellData data){    int bytes = 128;    char byte = 'A';    char *dir;    if(lenght < 1){        printf("Error.");        return;    }else dir = (char *) strtoul(trozos[0], NULL, 16);    if(lenght >= 2){        bytes = atoi(trozos[1]);    }    if(lenght >= 3){        byte = trozos[2][0];    }    for(int i = 0; i < bytes; i++){        dir[i] = byte;    }    printf("Rellenado %d bytes con valor %c a partir de la direccion %p\n", bytes, dir[0], dir);}enum memoryOption{    PRINTHELP_MEM,    ALL_MEM,    BLOCKS_MEM,    FUNCS_MEM,    VARS_MEM,    PMAP_MEM};static char cs1,cs2,cs3;float global1,global2,global3;void printVars(){    int local1,local2,local3;    printf("Variables locales   %18p,%18p,%18p\nVariables globales  %18p,%18p,%18p\n",&local1,&local2            ,&local3,&global1,&global2,&global3);    printf("Variables estaticas %18p,%18p,%18p\n",&cs1,&cs2,&cs3);}void printFuncs(){    printf("Funciones programa  %18p,%18p,%18p\nFunciones libreria  %18p,%18p,%18p\n",main,           memory,printFuncs,printf,fgets,malloc);}void memory(char * tokens[], int lenght, ShellData data){    enum memoryOption option = lenght==0?ALL_MEM:PRINTHELP_MEM;    if (lenght > 0) {        if (strcmp(tokens[0], "-all") == 0) {            option = ALL_MEM;        } else if (strcmp(tokens[0], "-blocks") == 0) {            option = BLOCKS_MEM;        } else if (strcmp(tokens[0], "-funcs") == 0) {            option = FUNCS_MEM;        } else if (strcmp(tokens[0], "-vars") == 0) {            option = VARS_MEM;        } else if (strcmp(tokens[0], "-pmap") == 0) {            option = PMAP_MEM;        }    }    switch (option) {        case PRINTHELP_MEM:            printf("Uso del comando %s:\n%s\n", MEMORY_NAME, MEMORY_DESCRIPTION);            break;        case ALL_MEM:            printVars();            printFuncs();            printListMem(data->memlist,-1);            break;        case BLOCKS_MEM:            printListMem(data->memlist,-1);            break;        case FUNCS_MEM:            printFuncs();            break;        case PMAP_MEM:            Do_pmap();            break;        case VARS_MEM:            printVars();            break;    }}void recurse(char * tokens[], int lenght, ShellData data){    if(lenght>=1){        Recursiva(atoi(tokens[0]));    }}//SE hace en el memoryvoid Do_pmap () /*sin argumentos*/{ pid_t pid;       /*hace el pmap (o equivalente) del proceso actual*/    char elpid[32];    char *argv[4]={"pmap",elpid,NULL};    sprintf (elpid,"%d", (int) getpid());    if ((pid=fork())==-1){        perror ("Imposible crear proceso");        return;    }    if (pid==0){        if (execvp(argv[0],argv)==-1)            perror("cannot execute pmap (linux, solaris)");        argv[0]="procstat"; argv[1]="vm"; argv[2]=elpid; argv[3]=NULL;        if (execvp(argv[0],argv)==-1)/*No hay pmap, probamos procstat FreeBSD */            perror("cannot execute procstat (FreeBSD)");        argv[0]="procmap",argv[1]=elpid;argv[2]=NULL;        if (execvp(argv[0],argv)==-1)  /*probamos procmap OpenBSD*/            perror("cannot execute procmap (OpenBSD)");        argv[0]="vmmap"; argv[1]="-interleave"; argv[2]=elpid;argv[3]=NULL;        if (execvp(argv[0],argv)==-1) /*probamos vmmap Mac-OS*/            perror("cannot execute vmmap (Mac-OS)");        exit(1);    }    waitpid (pid,NULL,0);}///Practica 3extern char **environ;//Proporcionada por el equipo docente y modificadavoid Cmd_fork (char * tokens[], int lenght, ShellData data){    pid_t pid;    if ((pid=fork())==0){/*		VaciarListaProcesos(&LP); Depende de la implementaciÃ³n de cada uno*/        clearList(data->proceslist);        printf ("ejecutando proceso %d\n", getpid());    }    else if (pid!=-1)        waitpid (pid,NULL,0);}//Proporcionada por el equipo docenteint BuscarVariable (char * var, char *e[])  /*busca una variable en el entorno que se le pasa como parÃ¡metro*/{    int pos=0;    char aux[MAXVAR];    strcpy (aux,var);    strcat (aux,"=");    while (e[pos]!=NULL)        if (!strncmp(e[pos],aux,strlen(aux)))            return (pos);        else            pos++;    errno=ENOENT;   /*no hay tal variable*/    return(-1);}// Proporcionada por el equipo docenteint CambiarVariable(char * var, char * valor, char *e[]) /*cambia una variable en el entorno que se le pasa como parÃ¡metro*/{                                                        /*lo hace directamente, no usa putenv*/    int pos;    char *aux;    if ((pos=BuscarVariable(var,e))==-1)        return(-1);    if ((aux=(char *)malloc(strlen(var)+strlen(valor)+2))==NULL)        return -1;    strcpy(aux,var);    strcat(aux,"=");    strcat(aux,valor);    e[pos]=aux;    return (pos);}/*las siguientes funciones nos permiten obtener el nombre de una senal a partirdel nÃºmero y viceversa *///Proporcionada por el equipo docentestatic struct SEN sigstrnum[]={        {"HUP", SIGHUP},        {"INT", SIGINT},        {"QUIT", SIGQUIT},        {"ILL", SIGILL},        {"TRAP", SIGTRAP},        {"ABRT", SIGABRT},        {"IOT", SIGIOT},        {"BUS", SIGBUS},        {"FPE", SIGFPE},        {"KILL", SIGKILL},        {"USR1", SIGUSR1},        {"SEGV", SIGSEGV},        {"USR2", SIGUSR2},        {"PIPE", SIGPIPE},        {"ALRM", SIGALRM},        {"TERM", SIGTERM},        {"CHLD", SIGCHLD},        {"CONT", SIGCONT},        {"STOP", SIGSTOP},        {"TSTP", SIGTSTP},        {"TTIN", SIGTTIN},        {"TTOU", SIGTTOU},        {"URG", SIGURG},        {"XCPU", SIGXCPU},        {"XFSZ", SIGXFSZ},        {"VTALRM", SIGVTALRM},        {"PROF", SIGPROF},        {"WINCH", SIGWINCH},        {"IO", SIGIO},        {"SYS", SIGSYS},/*senales que no hay en todas partes*/#ifdef SIGPOLL        {"POLL", SIGPOLL},#endif#ifdef SIGPWR        {"PWR", SIGPWR},#endif#ifdef SIGEMT        {"EMT", SIGEMT},#endif#ifdef SIGINFO        {"INFO", SIGINFO},#endif#ifdef SIGSTKFLT        {"STKFLT", SIGSTKFLT},#endif#ifdef SIGCLD        {"CLD", SIGCLD},#endif#ifdef SIGLOST        {"LOST", SIGLOST},#endif#ifdef SIGCANCEL        {"CANCEL", SIGCANCEL},#endif#ifdef SIGTHAW        {"THAW", SIGTHAW},#endif#ifdef SIGFREEZE        {"FREEZE", SIGFREEZE},#endif#ifdef SIGLWP        {"LWP", SIGLWP},#endif#ifdef SIGWAITING        {"WAITING", SIGWAITING},#endif        { NULL, -1},};    /*fin array sigstrnum *///Proporcionada con el equipo docentechar *NombreSenal(int sen)  /*devuelve el nombre senal a partir de la senal*/{			/* para sitios donde no hay sig2str*/    int i;    for (i=0; sigstrnum[i].nombre!=NULL; i++)        if (sen==sigstrnum[i].senal)            return sigstrnum[i].nombre;    return ("SIGUNKNOWN");}void execute(char * tokens[], int lenght, ShellData data){    int prioridad;    pid_t pid;    //Si el último argumento empieza por '@' cambiamos    //la prioridad antes de ejecutar    if(tokens[lenght-1][0] == '@'){        prioridad = atoi(&tokens[lenght-1][1]);        pid = getpid();        if((setpriority(PRIO_PROCESS, pid, prioridad))==-1){            perror("Imposible cambiar la prioridad");            return;        }        //Eliminamos el argummento con la prioridad        tokens[lenght-1] = (char*)NULL;        execvp(tokens[0], &tokens[0]);        //Sólo se llega aquí si no se ha realizado la sustitución de código -> Error        perror("Imposible ejecutar");    }else{        execvp(tokens[0], &tokens[0]);        //Sólo se llega aquí si no se ha realizado la sustitución de código -> Error        perror("Imposible ejecutar");    }}void priority(char *tokens[], int lenght,UNUSED ShellData data) {    int pid, prioridad;    if (lenght != 0) {        pid = atoi(tokens[0]);        if (lenght == 1) {            prioridad = getpriority(PRIO_PROCESS, pid);        } else {            prioridad = atoi(tokens[1]);            setpriority(PRIO_PROCESS, pid, prioridad);        }    }    else {        pid = getpid();        prioridad = getpriority(PRIO_PROCESS, pid);    }            printf("Prioridad del proceso %d es %d\n", pid, prioridad);}//Proporionada por el equipo docentevoid MuestraEntorno (char **entorno, char * nombre_entorno){    int i=0;    while (entorno[i]!=NULL) {        printf ("%p->%s[%d]=(%p) %s\n", &entorno[i],                nombre_entorno, i,entorno[i],entorno[i]);        i++;    }}void showenv(char *tokens[],int lenght, ShellData data) {    if (lenght != 0) {        if (strcmp(tokens[0], "-environ") == 0)            MuestraEntorno(environ, "environ");        else if (strcmp(tokens[0], "-addr") == 0) {            printf("environ:   %p (almacenado en %p)\n", &environ[0], &environ);            printf("main arg3:   %p (almacenado en %p)\n", &environ[0], &data->env);        }    }    else {        MuestraEntorno(environ,"main arg3");    }}void showvar (char *tokens[],int lenght, ShellData data){    int posicion;    char * ruta;    if (tokens[0]==NULL) {        MuestraEntorno(environ, "environ");        return;    }        if ((posicion=BuscarVariable(tokens[0], * data->env)) != -1) {            printf("Con argv3 main: %s(%p) @%p \n", (char *) (*data->env)[posicion], data->env[posicion],                   &(*data->env)[posicion]);        }        if((posicion=BuscarVariable(tokens[0],environ))!=-1) {            printf("Con environ: %s(%p) @%p \n", environ[posicion], environ[posicion], &environ[posicion]);        }        if  ((ruta = getenv(tokens[0])) == NULL)                perror("Imposible encontrar variable");        else            printf("Con getenv: %s(%p)\n",ruta,ruta);}void changevar(char *tokens[],int lenght, ShellData data) {    char unir[4096];    if (strcmp(tokens[0], "-a") == 0) {        CambiarVariable(tokens[1], tokens[2], *data->env);    } else if (strcmp(tokens[0], "-e") == 0) {        CambiarVariable(tokens[1], tokens[2], environ);    } else if (strcmp(tokens[0], "-p") == 0) {        sprintf(unir, "%s=%s", tokens[1], tokens[2]);        putenv(unir);    } else        printf("Use: changevar [-a|-e|-p] var valor\n");}//funciones para usar despuesstruct Proceso{    __pid_t pid;    int estado;    char comando[1024];    time_t inicio;    int code;    uid_t uid;};typedef struct Proceso Proceso;void Cmd_foreground(char *tokens[], int lenght, ShellData data) {    int prioridad;    int pid, estado;    if ((pid = fork()) == 0) {        //Si el último argumento empieza por '@' cambiamos        //la prioridad antes de ejecutar        if (tokens[lenght - 1][0] == '@') {            prioridad = atoi(&tokens[lenght - 1][1]);            pid = (int) getpid();            if ((setpriority(PRIO_PROCESS, pid, prioridad)) == -1) {                perror("Imposible cambiar la prioridad");                exit(1);            }            //Eliminamos le argumento con la prioridad            tokens[lenght - 1] = (char *) NULL;            execvp(tokens[0], &tokens[0]);        } else {            execvp(tokens[0], &tokens[0]);        }        perror("Imposible ejecutar comando");        return;    } else if (pid > 0) {        //Soy el padre y me quedo esperando a que termine el hijo        waitpid(pid, &estado, 0);        //Continuo a lo mio (ejecutando el shell)    } else {        perror("No se ha podido crear un nuevo proceso");    }}void update_process(Proceso * p){    int stat;    __pid_t pidt = waitpid(p->pid,&stat,WNOHANG |WUNTRACED |WCONTINUED);    if(pidt==(p->pid)){        if(WIFEXITED(stat))        {            p->estado=2;            p->code=WEXITSTATUS(stat);        }else if(WIFSIGNALED(stat))        {            p->estado=4;            p->code=WTERMSIG(stat);        }else{            if(WIFSTOPPED(stat))            {                p->estado=3;                p->code=WSTOPSIG(stat);            }            else{                p->estado=1;                p->code=0;            }        }    }}char * traducirEstado(int estado){    switch (estado) {        case 1:            return "ACTIVO";        case 2:            return "TERMINADO";        case 3:            return "PARADO";        case 4:            return "SENALADO";        default:            return "DESCONOCIDO";    }}void Cmd_delJobs(char *tokens[], int lenght, ShellData data){    bool term=false;    bool sig=false;    for(int i = 0;i<lenght;i++){        if(tokens[i][0]!='-')            continue;        if(strcmp(tokens[i],"-term")==0){            term=true;        }else if(strcmp(tokens[i],"-sig")==0){            sig=true;        }    }    int stop = 100000;    if (!isEmpty(data->proceslist)) {        pos p = first(data->proceslist);        for (int count = 0; !atEnd(data->proceslist, p) && count < stop; count++) {            Proceso *proc = ((Proceso *)getValue(data->proceslist, p));            update_process(proc);            pos pnext = next(data->proceslist, p);            if( (term && proc->estado==2) || (sig && proc->estado==4))            {                listremove(data->proceslist,p);            }            p = pnext;        }    }}//TODO señalvoid imprimir_proceso(Proceso * p){    char fecha[1024];    char user[1024];    char sen[16];    struct passwd *pwuid = getpwuid(p->uid);    if(pwuid == NULL){        sprintf(user,"uid %07d",p->uid);    } else        sprintf(user,"%s",pwuid->pw_name);    if(p->estado==4)    {        sprintf(sen,"%3s", NombreSenal(p->code));    } else{        sprintf(sen,"%03d",p->code);    }    //NombreSenal();    strftime(fecha,MAX,"%Y/%m/%d  %H:%M",localtime(&p->inicio));    //ValorSenal();    int prioridad = getpriority(PRIO_PROCESS, p->pid);    printf("%6d %s p=%d %s %s (%3s) %s\n",p->pid,user,prioridad,fecha, traducirEstado(p->estado), sen,p->comando);}void Cmd_listJobs(char *tokens[], int lenght, ShellData data){    int stop = 100000;    if (!isEmpty(data->proceslist)) {        pos p = first(data->proceslist);        for (int count = 0; !atEnd(data->proceslist, p) && count < stop; count++) {            Proceso *proc = ((Proceso *)getValue(data->proceslist, p));            update_process(proc);            imprimir_proceso(proc);            p = next(data->proceslist, p);        }    }else    {        printf("* Sin subprocesos *\n");    }}void Cmd_job(char *tokens[], int lenght, ShellData data){    int stop = 100000;    int recP = 0;    if(lenght==2 && tokens[0] && strcmp(tokens[0],"-fg")==0){        recP=strtol(tokens[1],NULL,10);        if (!isEmpty(data->proceslist)) {            pos p = first(data->proceslist);            for (int count = 0; !atEnd(data->proceslist, p) && count < stop; count++) {                Proceso *proc = ((Proceso *) getValue(data->proceslist, p));                if (proc->pid == recP) {                    if (proc->estado != 1) {                        printf("Proceso %d pid ya esta finalizado\n", recP);                        return;                    }                    printf("Proceso enviado a fg\n");                    int stat;                    __pid_t pidt = waitpid(proc->pid,&stat,0);                    if(pidt != proc->pid)                        return;                    if (WIFEXITED(stat)) {                        printf("Proceso %d terminado normalmente. Valor devuelto %d\n",proc->pid,                               WEXITSTATUS(stat));                    }                    if (WIFSIGNALED(stat)) {                        printf("Proceso %d terminado por la senal %s\n",proc->pid,NombreSenal(WTERMSIG(stat)));                    }                    listremove(data->proceslist,p);                    return;                }                p = next(data->proceslist, p);            }            Cmd_listJobs(NULL, 0, data);        }        return;    }    if(lenght>=1) {        recP=strtol(tokens[0],NULL,10);        if (!isEmpty(data->proceslist)) {            pos p = first(data->proceslist);            for (int count = 0; !atEnd(data->proceslist, p) && count < stop; count++) {                Proceso *proc = ((Proceso *) getValue(data->proceslist, p));                if (proc->pid == recP) {                    update_process(proc);                    imprimir_proceso(proc);                    return;                }                p = next(data->proceslist, p);            }            Cmd_listJobs(NULL, 0, data);        } else {            printf("* Sin subprocesos *\n");        }    }else{        Cmd_listJobs(NULL, 0, data);    }}void Cmd_background(char *tokens[], int lenght, ShellData data) {    int prioridad;    int pid;    if ((pid = fork()) == 0) {        //Soy el hijo        //Si el último argumento empieza por '@' cambiamos        //la prioridad antes de ejecutar        if (tokens[lenght - 1][0] == '@') {            prioridad = atoi(&tokens[lenght - 1][1]);            pid = (int) getpid();            if ((setpriority(PRIO_PROCESS, pid, prioridad)) == -1) {                perror("Imposible cambiar la prioridad");                exit(255);            }            //Eliminamos le argumento con la prioridad            tokens[lenght - 1] = (char *) NULL;            execvp(tokens[0], &tokens[0]);        } else {            execvp(tokens[0], &tokens[0]);        }        perror("Imposible ejecutar comando");        exit(255);    } else {        //Soy el padre, añado el hijo a la lista y continuo a lo mio (ejecutando el shell)        Proceso hijo;        char comando[MAXVAR] = "";        int i;        hijo.pid = pid;        for (i = 0; i < lenght; i++) {            strcat(comando, " ");            strcat(comando, tokens[i]);        }        strcpy(hijo.comando, comando);        hijo.inicio = time(NULL);        hijo.code=0;        hijo.estado=1;        hijo.uid=getuid();        insert(data->proceslist,&hijo,sizeof (Proceso));    }}