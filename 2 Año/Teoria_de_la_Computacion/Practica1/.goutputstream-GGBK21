1)

(* Función que verifica si un autómata finito no determinista con epsilon transiciones es AFNE o no *)
let es_afne (af : af) : bool =
  (* Creamos una variable para el símbolo épsilon *)
  let epsilon = Terminal "" in
  (* Obtenemos las transiciones del autómata finito *)
  let transiciones = match af with
    | Af(_, _, _, transiciones, _) -> transiciones
  in
  (* Función para verificar si un estado es AFNE *)
  let es_afne_estado estado =
    (* Obtenemos las transiciones que salen del estado actual usando el símbolo épsilon *)
    let transiciones_epsilon = filter (fun (Arco_af(estado_origen, _, simbolo)) -> estado_origen = estado && simbolo = epsilon) transiciones in
    (* Verificamos si existen transiciones que salgan del estado actual usando el símbolo épsilon *)
    let existe_transicion_epsilon = not (conjunto_is_empty transiciones_epsilon) in
    (* Obtenemos las transiciones que salen del estado actual sin usar el símbolo épsilon *)
    let transiciones_estado = filter (fun (Arco_af(estado_origen, _, simbolo)) -> estado_origen = estado && simbolo <> epsilon) transiciones in
    (* Obtenemos los destinos de las transiciones obtenidas anteriormente *)
    let destinos = map (fun (Arco_af(_, estado_destino, _)) -> estado_destino) transiciones_estado in
    (* Verificamos si existen transiciones que usen el símbolo épsilon y lleguen a algún estado destino obtenido anteriormente *)
    let existe_epsilon_destino = exists (fun estado_destino -> exists (fun (Arco_af(origen, _, simbolo)) -> origen = estado_destino && simbolo = epsilon) transiciones) destinos in
    (* El estado es AFNE si existe alguna transición que use el símbolo épsilon o alguna transición que llegue a un estado destino usando el símbolo épsilon *)
    existe_transicion_epsilon || existe_epsilon_destino
  in
  (* Obtenemos los estados del autómata finito *)
  let estados = match af with | Af(estados, _, _, _, _) -> estados in
  (* El autómata finito es AFNE si existe algún estado que sea AFNE *)
  exists es_afne_estado estados;;

///////////////////////////


(* Función que verifica si un autómata finito no determinista es AFN o no *)
let es_afn (af : af) : bool =
  (* Obtenemos las transiciones del autómata *)
  let transiciones = match af with
    | Af(_, _, _, transiciones, _) -> transiciones
  in
  (* Definimos una función que determina si un estado es AFN o no *)
  let es_afn_estado estado =
    (* Obtenemos las transiciones sin transiciones epsilon desde el estado *)
    let transiciones_estado = List.filter (fun (Arco_af(estado_origen, _, simbolo)) -> estado_origen = estado && simbolo <> Terminal "") (Conj.list_of_conjunto transiciones) in
    (* Obtenemos los destinos de las transiciones sin transiciones epsilon desde el estado *)
    let destinos = List.map (fun (Arco_af(_, estado_destino, _)) -> estado_destino) transiciones_estado in
    (* Obtenemos los destinos sin repeticiones y los ordenamos *)
    let destinos_sin_repeticion = List.sort_uniq compare destinos in
    (* El estado es AFN si tiene más de un destino *)
    List.length destinos <> List.length destinos_sin_repeticion
  in
  (* Obtenemos los estados del autómata *)
  let estados = Conj.list_of_conjunto (match af with | Af(estados, _, _, _, _) -> estados) in
  (* Verificamos si algún estado es AFN *)
  List.exists es_afn_estado estados;;

En resumen, la función recorre los estados y transiciones del autómata finito no determinista (AFN) y verifica si algún estado es AFN, es decir, si tiene más de un destino para alguna entrada de símbolos. Para ello, la función define varias funciones auxiliares que procesan las transiciones y estados del autómata.

La primera parte de la función obtiene las transiciones del autómata a partir del patrón Af(_, _, _, transiciones, _). La segunda parte de la función define la función es_afn_estado, que recibe como parámetro un estado y determina si es AFN o no. Para ello, la función filtra las transiciones que salen del estado (transiciones_estado) y obtiene los destinos de esas transiciones (destinos). Luego, ordena y elimina duplicados de destinos para obtener destinos_sin_repeticion. Si la longitud de destinos es diferente de la longitud de destinos_sin_repeticion, entonces el estado es AFN.

La tercera parte de la función obtiene los estados del autómata a partir del patrón Af(estados, _, _, _, _). Finalmente, la función utiliza la función es_afn_estado para verificar si algún estado del autómata es AFN. Si es así, entonces el autómata es AFN.
    
///////////////////////////////////777   
  
Aquí está el código con los comentarios que describen qué hace cada parte:

kotlin

let es_afd (af : af) : bool =
  (* Extraemos las transiciones del autómata *)
  let transiciones = match af with
    | Af(_, _, _, transiciones, _) -> transiciones
  in
  (* Función que comprueba si un estado es determinista *)
  let es_determinista_estado estado =
    (* Extraemos los símbolos de entrada del autómata *)
    let simbolos = match af with | Af(_, simbolos, _, _, _) -> simbolos in
    (* Comprobamos si para cada símbolo de entrada de los estados hay una única transición *)
    for_all (fun simbolo ->
        (* Filtramos las transiciones que van desde el estado actual y que utilizan el símbolo actual *)
        let transiciones_estado_simbolo = filter (fun (Arco_af(estado_origen, _, simbolo')) -> estado_origen = estado && simbolo' = simbolo) transiciones in
        (* Comprobamos que solo haya una transición *)
        cardinal transiciones_estado_simbolo = 1
      ) simbolos
  in
  (* Extraemos los estados del autómata y comprobamos si son todos deterministas *)
  let estados = match af with | Af(estados, _, _, _, _) -> estados in
  for_all es_determinista_estado estados;;


La función comienza extrayendo las transiciones del autómata, luego define una función auxiliar es_determinista_estado que determina si un estado dado del autómata es determinista (es decir, si para cada símbolo de entrada hay una única transición saliente del estado), y finalmente verifica que todos los estados del autómata sean deterministas. Si todos los estados son deterministas, la función devuelve true, de lo contrario, devuelve false  
  
  
  
2)let equivalentes (Af (estados1, alfabeto1, inicial1, transiciones1, finales1))
                  (Af (estados2, alfabeto2, inicial2, transiciones2, finales2)) =
  (* Función auxiliar para obtener el siguiente estado de un arco *)
  let estado_siguiente (Arco_af(_, s, _)) = s in
  (* Función auxiliar que verifica si algún estado es final *)
  let es_final finales estados =
    Conj.exists (fun e -> pertenece e finales) estados in
  (* Conjunto para almacenar los estados visitados *)
  let estados_visitados = ref Conj.conjunto_vacio in
  (* Cola para el algoritmo BFS. Inicialmente contiene los estados iniciales de ambos autómatas *)
  let cola = ref [(epsilon_cierre (Conj.agregar inicial1 Conj.conjunto_vacio) (Af (estados1, alfabeto1, inicial1, transiciones1, finales1)),
                  epsilon_cierre (Conj.agregar inicial2 Conj.conjunto_vacio) (Af (estados2, alfabeto2, inicial2, transiciones2, finales2)))] in
  (* Función recursiva BFS *)
  let rec bfs () =
    match !cola with
    | [] -> true
    | (estados_actuales1, estados_actuales2)::resto ->
      (* Si los estados actuales ya fueron visitados, se descartan y se continúa con el siguiente estado en la cola *)
      if Conj.pertenece (estados_actuales1, estados_actuales2) !estados_visitados then
      	(cola := resto;
      	 bfs ())
      else
        (* Se agregan los estados actuales al conjunto de visitados *)
        let estados_visitados' = Conj.agregar (estados_actuales1, estados_actuales2) !estados_visitados in
        (* Si los dos autómatas tienen un estado final y el otro no, entonces no son equivalentes *)
        if (es_final finales1 estados_actuales1 && not (es_final finales2 estados_actuales2)) ||
           (es_final finales2 estados_actuales2 && not (es_final finales1 estados_actuales1)) then
          false
        else
          (* Se calculan los nuevos estados alcanzables por cada símbolo del alfabeto *)
          let nuevos_estados = ref Conj.conjunto_vacio in
          iter (fun simbolo ->
            (* Se filtran los arcos correspondientes al símbolo actual *)
            let transiciones1' = filter (fun (Arco_af  (e1, _ , s1)) -> pertenece e1 estados_actuales1 && s1= simbolo) transiciones1 in
            let transiciones2' = filter (fun (Arco_af  (e2, _ , s2)) -> pertenece e2 estados_actuales2 && s2= simbolo) transiciones2 in
            (* Se obtienen los estados alcanzables a través de cada arco *)
            let sig1 = map estado_siguiente transiciones1' in 
            let sig2 = map estado_siguiente transiciones2' in
            (* Se calcula el cierre épsilon de los estados alcanzables *)
       (* Se calcula el epsilon-cierre de los estados sig1 y sig2 *)
let sig1_eps = epsilon_cierre sig1 (Af (estados1, alfabeto1, inicial1, transiciones1, finales1)) in
let sig2_eps = epsilon_cierre sig2 (Af (estados2, alfabeto2, inicial2, transiciones2, finales2)) in

(* Si alguno de los epsilon-cierres no es vacío, se agrega la pareja de estados a la lista de nuevos estados *)
if not (es_vacio sig1_eps) || not (es_vacio sig2_eps) then
    nuevos_estados := Conj.agregar (sig1_eps, sig2_eps) !nuevos_estados
) (union alfabeto1 alfabeto2);

(* Se actualiza la cola con los nuevos estados y los estados restantes *)
cola := (list_of_conjunto !nuevos_estados) @ resto;

(* Se actualiza la lista de estados visitados *)
estados_visitados := estados_visitados';

(* Se llama recursivamente a la función bfs para continuar con la búsqueda *)
bfs ()
;;
3) 

let escaner_afn cadena (Af (_, _, inicial, _, finales) as a) =
  (* Función auxiliar recursiva que determina si el autómata reconoce una cadena dada *)
  let rec reconoce_cadena = function
    (* Caso base: si no hay estados actuales o caracteres restantes, la cadena no es reconocida *)
    (Conjunto [], _) -> false
    (* Caso base: si no hay caracteres restantes y hay algún estado actual que sea final, la cadena es reconocida *)
  | (actuales, []) -> not (es_vacio (interseccion actuales finales))
    (* Caso recursivo: avanzamos el autómata al siguiente símbolo y seguimos verificando la cadena *)
  | (actuales, simbolo :: t) -> reconoce_cadena (avanza simbolo actuales a, t)
  in
  (* Comenzamos verificando la cadena desde el estado inicial del autómata *)
  reconoce_cadena (Conjunto [inicial], cadena);;

La función comienza definiendo una función auxiliar recursiva reconoce_cadena que determina si un autómata dado reconoce una cadena dada.

El primer caso base es cuando no hay estados actuales o caracteres restantes, en este caso la cadena no es reconocida y la función devuelve false.

El segundo caso base es cuando no hay caracteres restantes y hay algún estado actual que es final, en este caso la cadena es reconocida y la función devuelve true.

El caso recursivo es cuando todavía hay caracteres restantes en la cadena y necesitamos avanzar el autómata al siguiente símbolo de entrada. La función avanza se utiliza para calcular el conjunto de estados alcanzables desde los estados actuales al consumir el siguiente símbolo de entrada. Luego, llamamos a la función reconoce_cadena recursivamente con el nuevo conjunto de estados actuales y la cadena restante.

Finalmente, la función principal comienza verificando la cadena desde el estado inicial del autómata utilizando reconoce_cadena y devuelve el resultado.
//////////////////////

let escaner_afd cadena (Af (_, _, inicial, delta, finales) as a) =
  (* Función auxiliar recursiva que determina si el autómata reconoce una cadena dada *)
  let rec reconoce_cadena = function
    (* Caso base: si no hay estados actuales o caracteres restantes, la cadena no es reconocida *)
    (Conjunto [], _) -> false
    (* Caso base: si no hay caracteres restantes y hay algún estado actual que sea final, la cadena es reconocida *)
  | (actuales, []) -> not (es_vacio (interseccion actuales finales))
    (* Caso recursivo: avanzamos el autómata al siguiente símbolo y seguimos verificando la cadena *)
  | (actuales, simbolo :: t) -> 
      let siguientes = avanza simbolo actuales a in
      reconoce_cadena (siguientes, t)
  in
  (* Comenzamos verificando la cadena desde el estado inicial del autómata *)
  reconoce_cadena (Conjunto [inicial], cadena);;

La función comienza definiendo una función auxiliar recursiva reconoce_cadena que determina si un autómata dado reconoce una cadena dada.

El primer caso base es cuando no hay estados actuales o caracteres restantes, en este caso la cadena no es reconocida y la función devuelve false.

El segundo caso base es cuando no hay caracteres restantes y hay algún estado actual que es final, en este caso la cadena es reconocida y la función devuelve true.

El caso recursivo es cuando todavía hay caracteres restantes en la cadena y necesitamos avanzar el autómata al siguiente símbolo de entrada. La función avanza se utiliza para calcular el conjunto de estados alcanzables desde los estados actuales al consumir el siguiente símbolo de entrada. Luego, llamamos a la función reconoce_cadena recursivamente con el nuevo conjunto de estados actuales y la cadena restante.

Finalmente, la función principal comienza verificando la cadena desde el estado inicial del autómata utilizando reconoce_cadena y devuelve el resultado.

 
