let hd = function
    h :: _-> h
    | [] -> raise (Failure "hd");;

let tl = function
     _::  t -> t
    | [] -> raise (Failure "tl");;

let rec length = function
[] -> 0
| h::t -> 1 + length t;;

let rec compare_lengths = function
[] -> (function  [] -> 0 
        | _::_-> -1)
| h::t -> (function [] -> 1     
        | h2::t2 -> compare_lengths t t2) ;;


let rec nth l n = match l with
[] -> raise(Failure "nth")
|h::t when n = 0 -> h  
|h::t when n > 0 -> nth t (n-1)  
|h::t -> raise(Invalid_argument "nth");;

let rec append l1 l2 = match l1 with
      [] -> l2
      | h::t -> h :: append t l2;;


let rec find f l = match l with
[] -> raise(Not_found)
| h::t when f h -> h
| h::t -> find f t;;

let rec for_all f l = match l with
[] -> true
|h::t when f h -> for_all f t
|h::t -> false  ;;

let rec exists f l = match l with
[] -> false
|h::t when f h -> true    
|h::t -> exists f t  ;;

let rec mem x = function
[] -> false
| h::t -> x = h || mem x t ;;

let rec filter f l = match l with
[] -> []
|h::t when f h -> h::filter f t
|h::t -> filter f t;;

let find_all = filter;;

let partition f l = filter f l , 
filter (function x -> not (f x)) l;;

let rec split = function
[] -> [] , []
|(a,b)::t -> let (at,bt) =  split t  in
a::at , b::bt ;;

let rec combine l1 l2 = match l1 , l2 with
[],[] -> []
|h1::t1 , h2::t2 -> (h1,h2)::(combine t1 t2)  
| _ -> raise(Invalid_argument "combine");;

let rec aux x f n =  
        if x = n then [] 
        else f n::aux x f (n+1);;

let  init x f = if x < 0 then raise(Invalid_argument "init")
     else aux x f 0;;

let rec rev_append l1 l2 = match l1 with
[] -> l2
|h::t -> rev_append t (h::l2);;

let rev l = rev_append l [];;

let rec concat = function
  [] -> []
  | h::t ->
  append h (concat t);;

let flatten = concat;;

let rec map f = function
[] -> []
|h::t -> (f h)::(map f t);;

let rec rev_map f = function
[] ->[]
|h::t -> rev ((f h)::(map f t));;

let rec map2 f l1 l2=match(l1,l2) with
         ([],[])->[]
         |(h1::t1,h2::t2)->f h1 h2 :: map2 f t1 t2
         |(_,_)-> raise (Failure "map2");;


let rec fold_left op e = function
[] -> e
| h::t -> fold_left op (op e h) t;;

let rec fold_rigth op l e = match l with
[] -> e
| h::t -> op h (fold_rigth op t e);;










