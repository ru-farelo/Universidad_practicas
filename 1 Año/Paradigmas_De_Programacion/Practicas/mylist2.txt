let hd = function
    h :: _-> h
    | [] -> raise (Failure "hd");;

let tl = function
     _::  t -> t
    | [] -> raise (Failure "tl");;

let rec length = function
[] -> 0
| h::t -> 1 + length t;;

let rec compare_lengths = function
[] -> (function  [] -> 0 
        | _::_-> -1)
| h::t -> (function [] -> 1     
        | h2::t2 -> compare_lengths t t2) ;;


let rec nth l n = match l with
[] -> raise(Failure "nth")
|h::t when n = 0 -> h  
|h::t when n > 0 -> nth t (n-1)  
|h::t -> raise(Invalid_argument "nth");;

let rec append l1 l2 = match l1 with
      [] -> l2
      | h::t -> h :: append t l2;;


let rec find f l = match l with
[] -> raise(Not_found)
| h::t when f h -> h
| h::t -> find f t;;

let rec for_all f l = match l with
[] -> true
|h::t when f h -> for_all f t
|h::t -> false  ;;

let rec exists f l = match l with
[] -> false
|h::t when f h -> true    
|h::t -> exists f t  ;;

let rec mem x = function
[] -> false
| h::t -> x = h || mem x t ;;

let rec filter f l = match l with
[] -> []
|h::t when f h -> h::filter f t
|h::t -> filter f t;;

let find_all = filter;;

let partition f l = filter f l , 
filter (function x -> not (f x)) l;;

let rec split = function
[] -> [] , []
|(a,b)::t -> let (at,bt) =  split t  in
a::at , b::bt ;;

let rec combine l1 l2 = match l1 , l2 with
[],[] -> []
|h1::t1 , h2::t2 -> (h1,h2)::(combine t1 t2)  
| _ -> raise(Invalid_argument "combine");;

let init x f = let rec r_init aux  f n =
if n < 0 then aux else r_init (f n::aux)  f (n-1)
in if x < 0 then raise (Invalid_argument "init")
else  r_init []  f (x-1) ;;


let rec rev_append l1 l2 = match l1 with
[] -> l2
|h::t -> rev_append t (h::l2);;

let rev l = rev_append l [];;

let filter f l = let rec r_filter aux = function
|[] -> aux
|a::t -> if f a then r_filter (a::aux) t else r_filter aux t
in rev ( r_filter [] l) ;;

let find_all = filter;;

let partition f l = filter f l ,
filter (function x -> not (f x)) l;;

let rec concat = function
  [] -> []
  | h::t ->
  append h (concat t);;

let flatten = concat;;

let rec map f = function
[] -> []
|h::t -> (f h)::(map f t);;


let rev_map f l =
  let rec rmap_f aux = function
    | [] -> aux
    | a::l -> rmap_f (f a :: aux) l
  in
  rmap_f [] l;;

let rec fold_left op e = function
[] -> e
| h::t -> fold_left op (op e h) t;;

let rec fold_rigth op l e = match l with
[] -> e
| h::t -> op h (fold_rigth op t e);;





